<!-- http://codepen.io/anon/pen/jPgXVb-->
<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="theme-color" content="#000000">

	<title></title>
	<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
	<script src="lib.js"></script>
	<script src="matrix.js"></script>

	<link rel="stylesheet" type="text/css" href="display.css">
</head>
<body>
<div id="container">
	<div id="front" class="side">
		<canvas></canvas>
	</div>
	<div id="right" class="side">
		<canvas></canvas>
	</div>
	<div id="back" class="side">
		<canvas></canvas>
	</div>
	<div id="left" class="side">
		<canvas></canvas>
	</div>
</div>

<script type="text/javascript">
	var socket = io('/display');
	socket.on('refresh', function() {
		location.reload();
	});

	socket.on('disconnect', function() {
		setTimeout(function() {
			location.reload();
		}, 3000);
	});
</script>
<script type="text/javascript">

	var container = $('#container');
	var canvases = [].slice.call($$('canvas'));
	var size = Math.min(window.innerWidth, window.innerHeight);
	var middle = size / 2;
	canvases.forEach(function(canvas) {
		canvas.width = size;
		canvas.height = size / 2;
	});
	var ctxes = canvases.map(function(canvas) {
		return canvas.getContext('2d');
	});

	window.addEventListener('click', function(e) {
		container.webkitRequestFullScreen();
	});

	var tap = null;

	socket.on('touchstart', function(position) {
		tap = position;
	});
	socket.on('touchmove', function(position) {
		tap = position;
	});
	socket.on('touchend', function() {
		tap = null;
	});

	// var renderScreens = [cube, clock, touchTest, animationTest];
	var renderScreens = [cube, clock, touchTest, animationTest];

	function touchTest(ctx, time) {
		ctx.fillStyle = '#f00';
		if(tap) {
			ctx.fillRect(tap.x, tap.y, 50, 50);
		}
	}
	function animationTest(ctx, time) {
		var s = 100 + Math.sin(time/100)*50;
		ctx.save();
		ctx.translate(size / 2, size / 6);
		ctx.rotate(time / 300);
		ctx.fillStyle = '#f0f';
		ctx.fillRect(- s / 2,- s / 2, s, s);
		ctx.restore();
	}
	function pad(number) {
		return number > 9 ? number : '0' + number;
	}
	function clock(ctx, time) {
		var date = new Date();

		ctx.fillStyle = '#fff';
		ctx.font = "45px Arial";
		ctx.fillText(date.getHours() + ':' + pad(date.getMinutes()) + ':' + pad(date.getSeconds()), 130, 50);
	}
	function cube(ctx, time) {
		window.renderCube(ctx, time);
	}

	socket.on('rotate', function() {
		renderScreens.push(renderScreens.shift());
	});

	requestAnimationFrame(function render(time) {
		renderScreens.forEach(function(renderScreen, i) {
			var ctx = ctxes[i];
			ctx.clearRect(0, 0, size, size);
			// ctx.save();

			// ctx.translate(middle, middle);
			// ctx.rotate(i * Math.TAU / 4);
			// ctx.translate(-middle, -middle);
		
			// ctx.translate(size, 0);
			// ctx.scale(-1, 1);

			// ctx.beginPath();
			// ctx.moveTo(0, 0);
			// ctx.lineTo(middle, middle);
			// ctx.lineTo(size, 0);
			// ctx.closePath();
			// ctx.clip();

			renderScreen(ctx, time);
			
			// ctx.restore();
		});

		requestAnimationFrame(render);
		
	});

	//Copied from a different project
	(function() {
		var dist = 5;
	
		var cube = [
			vec3.fromValues(-dist, -dist, -dist),
			vec3.fromValues(-dist, -dist, dist),
			vec3.fromValues(dist, -dist, -dist),
			vec3.fromValues(dist, -dist, dist),
			vec3.fromValues(-dist, dist, -dist),
			vec3.fromValues(dist, dist, -dist),
			vec3.fromValues(dist, dist, dist),
			vec3.fromValues(-dist, dist, dist),
		];

		var width = height = size;

		var perspectiveMatrix = mat4.create();
		var near = 1, far = 1000;
		mat4.perspective(perspectiveMatrix, deg(60), width / height, near, far);

		var globalTransformation = mat4.create();
		mat4.translate(globalTransformation, globalTransformation, vec4.fromValues(0, 0, -100, 0));

		var cubeTransformation = mat4.create();
		var pyramidTransformation = mat4.create();

		function update(time) {
			mat4.rotateX(globalTransformation, globalTransformation, deg(1));
			mat4.rotateY(globalTransformation, globalTransformation, deg(0.5));
		}

		function render() {
			ctx.clearRect(0, 0, width, height);
				push(ctx, function() {
				ctx.translate(width / 2, height / 6);

				ctx.fillStyle = '#fff';
				renderPoints(ctx, cube, cubeTransformation);
			});
		}

		function renderPoints(ctx, points, localTransformation) {
			points.map(function(point) {
				var point4D = vec4.fromValues(point[0], point[1], point[2], 1);
				vec4.transformMat4(point4D, point4D, localTransformation);
				vec4.transformMat4(point4D, point4D, globalTransformation);
				vec4.transformMat4(point4D, point4D, perspectiveMatrix);
				return point4D;
			})
			.filter(function(point) {
				return point[2] > near && point[2] < far;
			})
			.map(function(point4D) {
				// var w = vec4.fromValues(point4D[3], point4D[3], point4D[3], point4D[3]);
				// vec4.divide(point4D, point4D, w);
				var point3D = vec3.fromValues(point4D[0] / point4D[3], point4D[1] / point4D[3], point4D[2] / point4D[3]);
				return point3D;
			})
			.forEach(function(point3D, index) {
				var w = 6, h = 6;
				var scale = Math.pow(point3D[2], -100) * 1/3;
				w *= scale;
				h *= scale;

				ctx.fillRect(point3D[0] * width - w / 2, point3D[1] * height - h / 2, w, h);
			});
		}

		function push(ctx, fn) {
			ctx.save();
			fn();
			ctx.restore();
		}

		function deg(angle) {
			return angle * Math.PI / 180;
		}
		var ctx;
		window.renderCube = function(_ctx, time) {
			ctx = _ctx;
			update(time);
			render();
		};
	})();
	

</script>
</body>
</html>

<!-- HTML
	<div id="container">
	<div id="container-inner">
	<div id="front" class="side"></div>
	<div id="right" class="side">
		<div id="test">Hej</div>  
	</div>
	<div id="back" class="side"></div>
	<div id="left" class="side"></div>
	</div>
</div>
-->
<!-- CSS
body {
	margin: 0;
	background: black;
}
#container {
	position: absolute;
	width: 100vh;
	height: 100vh;
	
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	margin: auto;
}
#container-inner {
}
#front, #back {
	width: 100%;
	height: 50%;
}
#left, #right {
	width: 100%;
	height: 50%;
	top: 25%;
}
#front {
	background: blue;
}
#left {
	background: red;
	transform: rotate(-90deg);
	left: -25%;
}
#right {
	background: green;
	transform: rotate(90deg);
	right: -25%;
}
#back {
	background: yellow;
	transform: rotate(180deg);
	bottom: 0;
	left: 0;
	right: 0;
}

.side {
	position: absolute;
	width: 100%;
	height: 50%;
	-webkit-clip-path: polygon(0% 0%, 50% 100%, 100% 0%);
}
#test {
	color: white;
	font-size: 65px;
	text-align: center;
	margin-top: 50px;
}
@media (max-aspect-ratio: 1/1) {
	#container {
		width: 100vw;
		height: 100vw;
	} 
}
-->
<!-- JS
//https://css-tricks.com/almanac/properties/c/clip/
//https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path
var container = document.querySelector('#container');
container.addEventListener('click', function(e) {
	container.webkitRequestFullScreen();
})
