<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta name="theme-color" content="#000000">

	<title></title>
	<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
	<script src="lib.js"></script>
	<script src="matrix.js"></script>

	<style type="text/css">

	body {
		margin: 0;
		padding: 0;
		background: black;
	}

	canvas {
		position: absolute;
		top: 0;
		left: 0;
		bottom: 0;
		right: 0;
		margin: auto;
		background: black;
	}

	</style>
</head>
<body>
	<canvas></canvas>

	<script type="text/javascript">
		var socket = io('/display');
		socket.on('refresh', function() {
			location.reload();
		});

		socket.on('disconnect', function() {
			setTimeout(function() {
				location.reload();
			}, 3000);
		});
	</script>
	<script type="text/javascript">

		var canvas = $('canvas');
		var size = Math.min(window.innerWidth, window.innerHeight);
		var middle = size / 2;
		canvas.width = canvas.height = size;

		var ctx = canvas.getContext('2d');

		window.addEventListener('click', function(e) {
			canvas.webkitRequestFullScreen();
		});

		var tap = null;

		socket.on('touchstart', function(position) {
			tap = position;
		});
		socket.on('touchmove', function(position) {
			tap = position;
		});
		socket.on('touchend', function() {
			tap = null;
		});

		var renderScreens = [cube, clock, touchTest, animationTest];

		function touchTest(time) {
			ctx.fillStyle = '#f00';
			if(tap) {
				ctx.fillRect(tap.x, tap.y, 50, 50);
			}
		}
		function animationTest(time) {
			var s = 100 + Math.sin(time/100)*50;
			ctx.save();
			ctx.translate(size / 2, size / 6);
			ctx.rotate(time / 300);
			ctx.fillStyle = '#f0f';
			ctx.fillRect(- s / 2,- s / 2, s, s);
			ctx.restore();
		}
		function pad(number) {
			return number > 9 ? number : '0' + number;
		}
		function clock(time) {
			var date = new Date();

			ctx.fillStyle = '#fff';
			ctx.font = "45px Arial";
			ctx.fillText(date.getHours() + ':' + pad(date.getMinutes()) + ':' + pad(date.getSeconds()), 130, 50);
		}
		function cube(time) {
			window.renderCube(time);
		}

		socket.on('rotate', function() {
			renderScreens.push(renderScreens.shift());
		});

		requestAnimationFrame(function render(time) {
			ctx.clearRect(0, 0, size, size);
			renderScreens.forEach(function(renderScreen, i) {
				ctx.save();

				ctx.translate(middle, middle);
				ctx.rotate(i * Math.TAU / 4);
				ctx.translate(-middle, -middle);
			
				ctx.translate(size, 0);
				ctx.scale(-1, 1);

				ctx.beginPath();
				ctx.moveTo(0, 0);
				ctx.lineTo(middle, middle);
				ctx.lineTo(size, 0);
				ctx.closePath();
				ctx.clip();

				renderScreen(time);
				
				ctx.restore();
			});

			requestAnimationFrame(render);
		});

		//Copied from a different project
		(function() {
			var dist = 5;
		
			var cube = [
				vec3.fromValues(-dist, -dist, -dist),
				vec3.fromValues(-dist, -dist, dist),
				vec3.fromValues(dist, -dist, -dist),
				vec3.fromValues(dist, -dist, dist),
				vec3.fromValues(-dist, dist, -dist),
				vec3.fromValues(dist, dist, -dist),
				vec3.fromValues(dist, dist, dist),
				vec3.fromValues(-dist, dist, dist),
			];

			var width = height = size;

			var perspectiveMatrix = mat4.create();
			var near = 1, far = 1000;
			mat4.perspective(perspectiveMatrix, deg(60), width / height, near, far);

			var globalTransformation = mat4.create();
			mat4.translate(globalTransformation, globalTransformation, vec4.fromValues(0, 0, -100, 0));

			var cubeTransformation = mat4.create();
			var pyramidTransformation = mat4.create();

			function update(time) {
				mat4.rotateX(globalTransformation, globalTransformation, deg(1));
				mat4.rotateY(globalTransformation, globalTransformation, deg(0.5));
			}

			function render() {
				ctx.clearRect(0, 0, width, height);
					push(ctx, function() {
					ctx.translate(width / 2, height / 6);

					ctx.fillStyle = '#fff';
					renderPoints(ctx, cube, cubeTransformation);
				});
			}

			function renderPoints(ctx, points, localTransformation) {
				points.map(function(point) {
					var point4D = vec4.fromValues(point[0], point[1], point[2], 1);
					vec4.transformMat4(point4D, point4D, localTransformation);
					vec4.transformMat4(point4D, point4D, globalTransformation);
					vec4.transformMat4(point4D, point4D, perspectiveMatrix);
					return point4D;
				})
				.filter(function(point) {
					return point[2] > near && point[2] < far;
				})
				.map(function(point4D) {
					// var w = vec4.fromValues(point4D[3], point4D[3], point4D[3], point4D[3]);
					// vec4.divide(point4D, point4D, w);
					var point3D = vec3.fromValues(point4D[0] / point4D[3], point4D[1] / point4D[3], point4D[2] / point4D[3]);
					return point3D;
				})
				.forEach(function(point3D, index) {
					var w = 6, h = 6;
					var scale = Math.pow(point3D[2], -100) * 1/3;
					w *= scale;
					h *= scale;

					ctx.fillRect(point3D[0] * width - w / 2, point3D[1] * height - h / 2, w, h);
				});
			}

			function push(ctx, fn) {
				ctx.save();
				fn();
				ctx.restore();
			}

			function deg(angle) {
				return angle * Math.PI / 180;
			}
			window.renderCube = function(time) {
				update(time);
				render();
			};
		})();
		

	</script>
</body>
</html>